# Algorithm-Visualization-Project - Product Requirements Document

**Author:** BMad
**Date:** 2025-11-19
**Version:** 1.0

---

## Executive Summary

**AlgoVision** 是一个面向算法学习者的交互式可视化平台，通过实时的、可暂停的算法执行和深度监控，帮助学生深入理解数据结构和算法的内部工作原理。

本项目作为现有 AlgoVision 平台的重大升级，将从当前的 6 个基础模块扩展为全面覆盖经典算法和 LeetCode 题目的综合学习工具。核心改进聚焦于：

1. **算法库扩充** - 从 6 个模块扩展到涵盖排序、搜索、树、图、动态规划、链表、哈希表等全面算法体系
2. **深度执行监控** - 增强变量状态追踪、调用栈可视化、内存状态展示、时间复杂度实时统计
3. **LeetCode 题目映射** - 将真实 LeetCode 题目与可视化一一对应，理论实践结合
4. **保持轻量化原则** - 零后端、零构建工具、纯浏览器运行，拒绝功能膨胀

### What Makes This Special

**AlgoVision 的独特价值：真正为学习者设计的本地化深度监控平台**

市场上存在多个算法可视化工具（VisuAlgo、Algorithm Visualizer），但 AlgoVision 的差异化在于：

- ✅ **极致轻量** - 无需安装、无需服务器、无需构建，打开浏览器即用
- ✅ **深度而非广度** - 不追求花哨功能，专注执行过程的深度理解
- ✅ **学习导向** - 与 LeetCode 题目结合，不是演示工具，而是学习工具
- ✅ **开源透明** - 代码可查、可改、可学习，本身就是教学资源

这不是另一个"算法动画播放器"，而是一个让学生**看见思考过程**的学习伴侣。

---

## Project Classification

**Technical Type:** web_app (Single Page Application)
**Domain:** edtech (Educational Technology)
**Complexity:** low-medium

本项目是基于现有 brownfield 代码库的功能增强，技术栈保持不变（HTML5 + Tailwind CSS + Vanilla JavaScript），通过扩充模块库和增强监控能力来实现教育价值提升。

作为教育工具，项目遵循轻量化原则，避免引入用户账户、数据收集、后端服务等复杂性。所有功能均在客户端完成，确保学生可以在任何环境下独立使用。

---

## Success Criteria

**成功的定义：学生能够通过 AlgoVision 深入理解算法的执行过程，而不仅仅是"看动画"。**

### 核心成功指标

1. **学习深度**
   - 学生能通过监控面板理解算法的每一步决策逻辑
   - 学生能观察到变量变化、调用栈演进、内存状态转换
   - 学生能理解时间复杂度与实际执行步数的对应关系

2. **算法覆盖**
   - 覆盖计算机科学基础课程中的所有经典算法（排序、搜索、树、图、DP）
   - 覆盖 LeetCode 高频题目的可视化（至少 50+ 题目映射）
   - 支持两大类别：数据结构操作 + 算法问题求解

3. **使用体验**
   - 学生能在 3 分钟内上手使用（零学习成本）
   - 平台保持轻量级（总加载时间 < 3 秒）
   - 在任何现代浏览器中流畅运行（无需安装、配置）

4. **开源影响力**
   - 项目成为教育领域的参考实现
   - 代码可读性足够高，本身可作为学习材料
   - 社区贡献者能轻松添加新算法模块

---

## Product Scope

### MVP - Minimum Viable Product

**核心能力：将现有 6 个模块扩展到 30+ 算法，并增强监控功能**

#### 1. 算法库扩充（优先级排序）

**Phase 1: 排序算法补全**
- 归并排序 (Merge Sort)
- 堆排序 (Heap Sort)
- 希尔排序 (Shell Sort)
- 计数排序 (Counting Sort)
- 基数排序 (Radix Sort)

**Phase 2: 搜索算法**
- 二分搜索 (Binary Search)
- 深度优先搜索 (DFS)
- 广度优先搜索增强（已有 BFS，增强展示）

**Phase 3: 树结构**
- 二叉搜索树 (BST) - 插入、删除、搜索
- AVL 树 - 自平衡操作
- 红黑树 - 插入与旋转

**Phase 4: 图算法**
- Dijkstra 最短路径
- Prim 最小生成树
- Kruskal 最小生成树
- 拓扑排序

**Phase 5: 动态规划**
- 0-1 背包问题
- 最长公共子序列 (LCS)
- 最长递增子序列 (LIS)
- 编辑距离

**Phase 6: 链表与哈希**
- 链表操作（反转、合并、检测环）
- 哈希表冲突解决（链地址法、开放寻址）

#### 2. 深度监控功能

**变量状态追踪**
- 实时显示当前算法中的关键变量（如循环变量 i、j，指针 left、right 等）
- 变量变化历史记录（可回溯查看）

**调用栈可视化**
- 递归算法的调用栈展示（如快速排序、归并排序、DFS）
- 栈帧信息（参数、返回值、执行点）

**内存状态展示**
- 数组/链表/树/图的内存布局可视化
- 对象引用关系图（特别是图和树结构）

**时间复杂度统计**
- 实时统计比较次数、交换次数、访问次数
- 显示理论复杂度 vs 实际执行步数
- 最好/平均/最坏情况的对比

#### 3. LeetCode 题目映射

**题目选择标准**
- 覆盖 LeetCode Easy/Medium 难度的经典题目
- 优先选择面试高频题（如两数之和、反转链表、二叉树遍历等）
- 每个算法至少对应 2-3 个 LeetCode 题目

**映射方式**
- 每个模块卡片显示对应的 LeetCode 题号和标题
- 可视化执行时显示题目描述和解题思路
- 提供题目链接（跳转到 LeetCode 原题）

#### 4. 保留轻量化特性

**必须保持的约束**
- ❌ 不引入用户账户系统
- ❌ 不引入后端服务
- ❌ 不引入构建工具（保持纯 HTML/CSS/JS）
- ❌ 不引入进度保存功能
- ✅ 继续使用 CDN 依赖（Tailwind、Lucide）
- ✅ 单文件架构（algorithm.html 包含所有逻辑）

### Growth Features (Post-MVP)

**Phase 7: 更多算法**
- 字符串算法（KMP、Manacher）
- 高级数据结构（线段树、树状数组、并查集）
- 贪心算法可视化
- 回溯算法可视化（N 皇后、数独求解）

**Phase 8: 用户体验增强**
- 代码对比功能（显示 C++、Java、Python 多语言实现）
- 自定义输入数据（学生可输入自己的测试用例）
- 执行速度调节（更细粒度的速度控制）
- 暗黑/明亮主题切换

**Phase 9: 分享与协作**
- 生成可分享的链接（通过 URL 参数传递算法和数据）
- 导出执行日志（学生可保存学习记录）
- 代码片段导出（导出当前算法的代码实现）

### Vision (Future)

**Phase 10: 移动端优化**
- 响应式设计优化（支持平板和手机）
- 触控手势支持（拖拽、缩放）

**Phase 11: 可访问性**
- 键盘导航支持
- 屏幕阅读器支持（ARIA 标签）
- 高对比度模式

**Phase 12: 模块化架构**
- 将算法模块提取到独立 JSON 文件
- 支持动态加载模块（按需加载，减少初始加载时间）
- 社区可贡献新算法模块（通过 PR 添加 JSON 文件）

---

## Web App Specific Requirements

作为单页应用（SPA），AlgoVision 的技术实现需要满足以下 Web 平台特定要求：

### 浏览器兼容性

**支持的浏览器**
- Chrome/Edge 90+ （主要目标）
- Firefox 88+
- Safari 14+
- Opera 76+

**不支持的浏览器**
- Internet Explorer（已停止支持）
- 移动浏览器（MVP 阶段暂不优化，但应能基本运行）

**兼容性策略**
- 使用标准 ES6+ JavaScript 特性（所有现代浏览器均支持）
- 依赖 Tailwind CSS v3（通过 CDN 加载）
- 使用 Generator 函数（已在所有目标浏览器中原生支持）
- 避免使用实验性 API

### 响应式设计（MVP 范围）

**桌面优先策略**
- 主要优化目标：1920x1080、1366x768、1440x900 分辨率
- 最小支持宽度：1024px（笔记本电脑）
- 布局模式：固定侧边栏 + 可缩放主视图

**组件响应性**
- 可视化画布根据窗口大小自动调整
- 控制面板保持固定宽度（320px）
- 监控面板可折叠/展开

**移动端考虑**
- MVP 不要求移动端优化
- 但应确保在平板（≥768px）上可基本使用
- 全面移动支持留待 Phase 10（Vision）

### 性能目标

**加载性能**
- 首次内容绘制（FCP）：< 1.5 秒
- 最大内容绘制（LCP）：< 2.5 秒
- 首次交互时间（TTI）：< 3 秒
- HTML 文件大小：< 200KB（包含所有 30+ 模块后）

**运行时性能**
- 动画帧率：≥ 30 FPS（目标 60 FPS）
- Generator 执行延迟：< 50ms（单步执行响应时间）
- 内存占用：< 50MB（单个标签页）
- 支持的最大数据规模：数组 1000 个元素、图 100 个节点

### SEO 与可发现性

**SEO 要求**
- 提供静态 landing page（index.html）供搜索引擎抓取
- 使用语义化 HTML 标签（`<header>`, `<main>`, `<nav>`, `<article>`）
- 添加 Open Graph meta 标签（社交媒体分享）
- 生成 sitemap.xml（列出所有算法模块）

**元数据**
```html
<meta name="description" content="Interactive algorithm visualization...">
<meta name="keywords" content="algorithm,visualization,leetcode,learning">
<meta property="og:title" content="AlgoVision - Algorithm Visualizer">
<meta property="og:image" content="preview.png">
```

### 部署与分发

**静态托管**
- GitHub Pages（主要推荐）
- Netlify / Vercel（备选）
- 本地文件系统（file:// 协议需兼容）

**CDN 依赖管理**
- Tailwind CSS：使用稳定版本 CDN 链接
- Lucide Icons：锁定特定版本避免 breaking changes
- Google Fonts：使用 font-display: swap 优化加载
- 备用方案：提供 CDN 失败时的本地回退

### 无障碍访问（MVP 基础）

**基础可访问性**
- 使用 `alt` 属性描述所有可视化元素
- 提供键盘快捷键（空格=播放/暂停，左右箭头=步进）
- 确保对比度符合 WCAG AA 标准（4.5:1）

**增强可访问性（Phase 11）**
- 完整键盘导航
- ARIA 标签
- 屏幕阅读器支持

---

## User Experience Principles

### 设计理念：简洁、直观、以学习为中心

**核心设计原则**

1. **零学习曲线**
   - 打开页面即可看到算法列表，一键启动可视化
   - 控制按钮使用通用图标（播放▶、暂停⏸、步进⏭）
   - 无需阅读文档即可上手

2. **可见即可理解**
   - 算法执行的每一步都清晰标注当前操作（"Comparing indices 2 and 5"）
   - 变量状态实时显示在监控面板，无需猜测
   - 颜色编码一致性（红色=比较中、绿色=已排序、黄色=当前操作）

3. **控制感与探索感**
   - 学生可随时暂停、步进、重置
   - 可调整执行速度（从慢动作到快速播放）
   - 可自定义输入数据（输入自己的测试用例）

4. **专注核心价值**
   - 界面无杂乱元素，仅保留学习必需功能
   - 主视图占据 70% 屏幕空间，监控面板 30%
   - 避免花哨动效，保持专业学习工具的严肃性

### 视觉个性

**主题风格：暗黑科技风**
- 延续现有暗黑主题（深蓝黑背景 #020617）
- Glassmorphism 效果（毛玻璃卡片）
- 渐变强调色（Cyan #06b6d4 → Purple #8b5cf6）

**字体选择**
- 标题：Inter（现代、清晰）
- 代码：JetBrains Mono（等宽，适合代码显示）
- 正文：Inter（保持统一性）

### 关键交互模式

**模块选择流程**
1. Dashboard 展示所有算法卡片（网格布局）
2. 卡片悬停显示 LeetCode 题目链接
3. 点击卡片进入可视化页面
4. 返回按钮回到 Dashboard

**可视化执行流程**
1. 页面加载显示初始数据状态
2. 点击"播放"开始自动执行
3. 每一步显示当前操作描述 + 变量状态
4. 监控面板实时更新统计信息
5. 执行完成显示总结（比较次数、交换次数、时间复杂度）

**监控面板交互**
- 默认展开显示核心信息（当前变量、步骤计数）
- 可折叠高级监控（调用栈、内存布局）
- 悬停变量名显示详细说明（"i: 循环索引，从 0 到 n-1"）

---

## Functional Requirements

> **关键说明**: 以下功能需求是所有后续工作的基础 - UX 设计、架构设计、Epic 分解都基于此列表。每个能力都必须在最终产品中实现。

### 算法模块管理

**FR1**: 系统应展示所有可用的算法和数据结构模块，按类别分组（排序、搜索、树、图、动态规划、链表、哈希）

**FR2**: 每个模块卡片应显示算法名称、类型、时间复杂度、对应的 LeetCode 题目编号

**FR3**: 用户可通过点击模块卡片进入该算法的可视化页面

**FR4**: 用户可通过类别筛选器过滤模块列表（如仅显示"排序算法"）

**FR5**: 用户可通过搜索框按名称或 LeetCode 题号搜索算法

### 可视化执行控制

**FR6**: 用户可启动算法的自动执行（播放模式）

**FR7**: 用户可暂停正在执行的算法

**FR8**: 用户可单步执行算法（步进模式，每次执行一个 yield 步骤）

**FR9**: 用户可重置算法到初始状态

**FR10**: 用户可调整自动执行的速度（慢速、中速、快速，对应 1x、2x、4x）

**FR11**: 用户可随时跳转到任意执行步骤（拖动进度条）

### 数据输入与定制

**FR12**: 用户可使用系统提供的默认测试数据执行算法

**FR13**: 用户可输入自定义数据（数组、图的邻接表、树的节点值等）

**FR14**: 系统应验证用户输入的数据格式，并在格式错误时提示

**FR15**: 用户可从预设的测试用例中选择（如"已排序数组"、"逆序数组"、"随机数组"）

### 变量状态监控

**FR16**: 系统应实时显示算法中的关键变量值（如循环变量 i、j，指针 left、right，临时变量 temp）

**FR17**: 变量值变化时应高亮显示（如 i 从 2 变为 3 时短暂高亮）

**FR18**: 用户可查看变量的变化历史（点击变量名显示历史值列表）

**FR19**: 系统应显示当前执行步骤的描述（如"Comparing arr[2] and arr[5]"）

### 调用栈可视化

**FR20**: 对于递归算法，系统应显示当前的调用栈

**FR21**: 调用栈应展示每个栈帧的参数、局部变量、返回值

**FR22**: 用户可点击栈帧查看该层级的详细信息

**FR23**: 递归调用时，栈帧应以动画形式入栈；返回时应出栈

### 内存状态可视化

**FR24**: 对于数组，系统应显示数组的内存布局（索引 + 值）

**FR25**: 对于链表，系统应显示节点和指针关系（节点值 + next 指针）

**FR26**: 对于树，系统应显示树的结构（节点 + 父子关系）

**FR27**: 对于图，系统应显示节点和边的关系（邻接矩阵或邻接表形式）

**FR28**: 当前操作的内存位置应高亮显示（如正在访问的数组索引）

### 时间复杂度统计

**FR29**: 系统应实时统计算法的比较次数

**FR30**: 系统应实时统计算法的交换/移动次数

**FR31**: 系统应实时统计算法的数组访问次数

**FR32**: 执行完成后，系统应显示理论时间复杂度 vs 实际执行步数的对比

**FR33**: 系统应显示最好/平均/最坏情况的复杂度说明

### LeetCode 题目集成

**FR34**: 每个算法模块应关联至少一个 LeetCode 题目

**FR35**: 模块卡片应显示关联的 LeetCode 题号和题目标题

**FR36**: 用户可点击题目链接跳转到 LeetCode 原题页面（新标签页打开）

**FR37**: 可视化页面应显示题目描述和解题思路

**FR38**: 系统应标注题目难度（Easy / Medium / Hard）

### 代码展示

**FR39**: 系统应显示当前算法的 C++ 参考代码

**FR40**: 代码应与可视化同步（当前执行行高亮显示）

**FR41**: 用户可复制代码到剪贴板

**FR42**: 代码应包含详细注释，解释每个步骤的逻辑

### 导航与路由

**FR43**: 用户可从任何可视化页面返回到 Dashboard（算法列表）

**FR44**: 系统应支持浏览器的前进/后退按钮（客户端路由）

**FR45**: URL 应反映当前状态（如 #/algorithm/bubble-sort）

**FR46**: 用户可通过 URL 直接访问特定算法（书签/分享）

### 用户界面状态

**FR47**: 用户可折叠/展开监控面板以获得更大的可视化空间

**FR48**: 用户可折叠/展开代码面板

**FR49**: 系统应记住用户的面板折叠状态（使用 localStorage）

**FR50**: 用户可切换暗黑/明亮主题（Post-MVP，Phase 8）

---

## Non-Functional Requirements

### Performance

**NFR-P1: 页面加载速度**
- 首次内容绘制（FCP）必须 < 1.5 秒
- HTML 文件包含 30+ 模块后仍需 < 200KB
- 所有 CDN 资源（Tailwind、Lucide）应使用缓存

**NFR-P2: 运行时性能**
- 可视化动画帧率必须 ≥ 30 FPS
- Generator 单步执行延迟必须 < 50ms（用户感知为即时响应）
- 支持数组规模最大 1000 个元素、图最大 100 个节点

**NFR-P3: 内存效率**
- 单个标签页内存占用必须 < 50MB
- 切换模块时应释放前一个模块的内存
- 避免内存泄漏（特别是 SVG 图形和事件监听器）

**为什么这些性能要求重要？**
学生的学习体验直接受性能影响 - 卡顿的动画会打断思考，缓慢的加载会降低使用意愿。轻量化原则不仅是技术约束，更是教育产品的核心价值。

### Security

**NFR-S1: 客户端安全**
- 所有用户输入必须经过验证和清理（防止 XSS）
- 不执行用户提供的任意代码（仅解析数据结构）
- 使用 CSP（Content Security Policy）限制外部资源加载

**NFR-S2: 依赖安全**
- CDN 依赖必须使用 SRI（Subresource Integrity）校验
- 锁定 CDN 版本，避免自动更新引入的安全风险
- 定期审计依赖的已知漏洞

**为什么安全重要？**
虽然是教育工具，但面向学生用户，必须确保不会因为代码漏洞导致浏览器被恶意利用。开源项目尤其需要对安全负责。

### Accessibility

**NFR-A1: 基础可访问性（MVP）**
- 所有交互元素必须支持键盘操作（Tab、Enter、Space、Arrow Keys）
- 色彩对比度必须符合 WCAG 2.1 Level AA（4.5:1）
- 关键交互提供视觉反馈（焦点状态、hover 状态）

**NFR-A2: 增强可访问性（Phase 11）**
- 支持屏幕阅读器（ARIA 标签完整标注）
- 提供高对比度模式
- 支持缩放（200% 不破坏布局）

**为什么可访问性重要？**
教育工具应面向所有学生，包括视觉障碍、色盲、运动障碍的学生。虽然 MVP 不要求完整支持，但基础可访问性是必需的。

### Scalability

**NFR-SC1: 模块扩展性**
- 添加新算法模块应仅需修改 `modules[]` 数组，无需改动核心逻辑
- 单个模块定义应 < 200 行代码
- 模块间应零耦合（互不依赖）

**NFR-SC2: 代码可维护性**
- JavaScript 代码应遵循 ES6+ 标准
- 函数应保持单一职责，单个函数 < 50 行
- 关键逻辑应有注释（特别是 Generator 函数和渲染逻辑）

**NFR-SC3: 社区贡献友好**
- 添加算法的指南应清晰（在 development-guide.md 中）
- 提供模块模板代码（复制-粘贴-修改即可）
- PR 审查流程应自动化（GitHub Actions 检查代码格式）

**为什么可扩展性重要？**
从 6 个模块扩展到 30+，未来可能达到 50+、100+。如果没有良好的扩展性设计，项目会变得无法维护。开源项目尤其需要社区贡献友好。

---

_This PRD captures the essence of Algorithm-Visualization-Project - 一个让学生真正"看见思考过程"的轻量级、深度监控、开源的算法学习工具。_

_Created through collaborative discovery between BMad and PM John (AI facilitator)._
